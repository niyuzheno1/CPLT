#include <tree_sitter\api.h>
#include <iostream>
#include <string>
#include <vector>
#include <fstream>
#include <sstream>
#include <iomanip>
#include <functional>
#include <algorithm>
#include <set>
#include <map>
#include <assert.h>
#include <clay.h>
using namespace std;
#ifdef _DEBUG
const int c_dbg = 0;
#else
const int c_dbg = 0;
#endif
// you can navigate using bread crumb

bool forced_display_variable_insertion = false;

//linking_begin
//linking_end

namespace tree_sitter_memory_management{
    class MemoryManager{
    public:
        template<typename T>
        T* newInstance(){
            return new T();
        }
    } ;
    MemoryManager memoryManager;

};

#define addp(s) if(true){ data_type* ndt = data_type::newInstance();\
ndt->content =  s;\
dt->sq.push_back(ndt);\
dt->isSequential = true;\
}\
\
\


#define addpp(s, x, y) if(true){ data_type* nndt = data_type::newInstance();\
nndt->content =  x;\
nndt->type = y;\
s->push_back(nndt);\
s->isSequential = true;\
}\
\
\

namespace tree_sitter_declaration_space {
    using namespace tree_sitter_memory_management;
    class data_type;
    using Seq = vector<data_type*>;
    class data_type{
    public:
        data_type * parent;
        data_type(){
            parent = nullptr;
            type = "";
            sq = Seq();
            isSequential = false; 
            content = "";
        }
        string type; 
        virtual string getBaseType(){
            return "";
        }
        Seq sq;
        bool isSequential;
        string content; 
        static data_type * newInstance(){
            return memoryManager.newInstance<data_type>();
        } 
        void add(data_type * d){
            sq.push_back(d);
            if(d != nullptr){
                d->parent = this;
            }
            isSequential = true;
        }
        void push_back(data_type * d){
            add(d);
        }
        void addAll(const Seq & s){
            for(auto & d : s){
                sq.push_back(d);
                if(d != nullptr) d->parent = this;
            }
            isSequential = true;
        }
        void show(){
            cout << content ;
            for(int i = (0); i < (sq.size()); i++){
                sq[i]->show();
            }
        }

        void show_debug(int level){
#ifdef _DEBUG
            //repeat '\t' level times
            for(int i = (0); i < (level); i++){
                cerr << "\t";
            }
            cerr  << "node_type[" << type << "] :" << content ;
            cerr << endl;
            for(int i = (0); i < (sq.size()); i++){
                sq[i]->show_debug(level + 1);
            }
#endif
        }
        data_type * operator[](int idx){
            return sq[idx];
        }
        size_t size(){
            return sq.size();
        }
        bool isString(){
            if(size() == 0){
                return true;
            }
            if(size() == 1 && sq[0]->size() == 1 && !sq[0]->isSequential){
                return true;
            }
            return false;
        }
        string toString(){
            string ret = "";
            ret += content;
            for(int i = (0); i < ((int)((*this).size())); i++){
                ret += sq[i]->toString();
            }
            return ret;
        }
        
        data_type * get(int idx){
            Seq s;
            for(auto & x : sq){
                if(x->type == "") continue;
                s.push_back(x);
            }
            return s[idx];
        }
    };
    using vpdtpdt = vector<pair<data_type*, data_type*>>;

    class function_definition_data_type : public data_type{
    public:
        vpdtpdt usages;
        function_definition_data_type(){
            data_type();
            usages = vpdtpdt();
            type = "function_definition";
        }
        string getBaseType() override{
            return "function_definition";
        }
        static function_definition_data_type * newInstance(){
            return memoryManager.newInstance<function_definition_data_type>();
        }
    };

    class parameter_list_data_type : public data_type{
    public:
        parameter_list_data_type(){
            data_type();
            type = "parameter_list";
            sq = Seq();
            isSequential = false; 
            content = "";
        }
        string getBaseType() override{
            return "parameter_list";
        }
        int getArgsCount(){
            int cnt = 0;
            int flag = 0;
            for(auto & x : sq){
                if(x->type == "(") flag = 1;
                if(x->type == ")") flag = 0;
                if(x->type != "" && x->type != "," && x->type != "(" && flag == 1){
                    cnt++;
                }
            }
            return cnt;
        }
        static parameter_list_data_type * newInstance(){
            return memoryManager.newInstance<parameter_list_data_type>();
        }
    };  


    class class_specifier_data_type : public data_type{
        public:
            class_specifier_data_type(){
                data_type::data_type();
                type = "class_specifier";
            }
            string getBaseType() override{
                return "class_specifier";
            }
            string type_identifier_name;
            static class_specifier_data_type * newInstance(){
                return memoryManager.newInstance<class_specifier_data_type>();
            }

            string getName(){
                for(auto & x : sq){
                    if(x->type == "type_identifier"){
                        return x->toString();
                    }
                }
                return "";
            }
    };

   
    class function_declarator_data_type : public data_type{
    public:
        function_declarator_data_type(){
            data_type();
            name = "";
            args = 0;
            type = "function_declarator";
            sq = Seq();
            isSequential = false; 
            content = "";
        }
        string getBaseType() override{
            return "function_declarator";
        }
        static function_declarator_data_type * newInstance(){
            return memoryManager.newInstance<function_declarator_data_type>();
        }
        string name;
        int args = 0;
    };

    pair<string,int> getFunctionDeclaration(data_type * dt){
        if(dt->getBaseType() != "function_declarator"){
            for(auto & y : dt->sq){
                auto ret = getFunctionDeclaration(y);
                if(ret.second != -1){
                    return ret;
                }
            }
            return make_pair("", -1);
        }
        function_declarator_data_type* ddt = dynamic_cast<function_declarator_data_type*>(dt);
        if(ddt == nullptr){
            return make_pair("", -1);
        }
        return make_pair(ddt->name, ddt->args);
    }
    string getVariableDeclaration(data_type * dt){
        if(dt->type != "identifier"){
            for(auto & y : dt->sq){
                auto ret = getVariableDeclaration(y);
                if(ret != ""){
                    return ret;
                }
            }
            return "";
        }
        return dt->toString();
    }
    class DataTypeStream{
    public:
        DataTypeStream(){
            dt = data_type::newInstance();
        }
        data_type * dt;
        DataTypeStream& operator<<(string s){
            addp(s);
            return *this;
        }        
        DataTypeStream& operator<<(data_type * d){
            dt->add(d);
            dt->isSequential = true;
            return *this;
        }
        data_type * getDataType(){
            return dt;
        }
        Seq getSeq(){
            return dt->sq;
        }
    };
};

using namespace tree_sitter_declaration_space;



namespace tree_sitter_util {
    string to_string(stringstream & x){
        #undef str 
        return x.str();
        #define str string
    }
    template<typename T>
    set<T> toSet(vector<T> & t){
        set<T> s;
        for(auto & i : t)s.insert(i);
        return s;
    }
    template<typename T>
    set<T> mergeSet(set<T> & s1, set<T> & s2){
        set<T> s;
        for(auto & i : s1)s.insert(i);
        for(auto & i : s2)s.insert(i);
        return s;
    }
    template<typename T>
    string toString(vector<T> & t){
        stringstream ss;
        ss << "[";
        for(int i = (0); i < ((int)((t).size())); i++){
            ss << t[i];
            if(i != (int)((t).size()) - 1)
                ss << ", ";
        }
        ss << "]";
        //fix later
        return to_string(ss);
    }
}

using namespace tree_sitter_util;

namespace tree_sitter_data_structures {
    using namespace tree_sitter_declaration_space;
    using variable_definition = pair<string, int>; //name + int
    using variable_definition_body = vpdtpdt; //data_type* 
    using MVD = map<variable_definition, variable_definition_body>; // -1 = variable
    class Scope{
    public:
        bool isInserting = false;
        MVD vvd;
        vpdtpdt vUsage; 
        void add_function(string name, int args, data_type * dt, data_type * dt2){
            vvd[{name, args}].push_back(make_pair(dt, dt2));
        }
        void add_variable(string name, data_type * dt, data_type * dt2){
            vvd[{name, -1}].push_back(make_pair(dt, dt2));
        }
        Scope * parent;
        Scope(Scope * parent){
            this->parent = parent;
            isInserting = false;
        }

        void passdown(Scope & x){
            x.buffer = this->buffer;
            x.vUsage = vpdtpdt();
            x.tsParser = this->tsParser;
            x.isInserting = this->isInserting;
        }

        vpdtpdt getAllUsage(string name, int args){
            vpdtpdt ret;
            if(vvd.count({name, args}) == 0){
                if(parent != nullptr){
                    ret = parent->getAllUsage(name, args);
                }
            }
            else{
                ret = vvd[{name, args}];
            }
            return ret;
        }
        
        string * buffer;
        TSParser * tsParser;
        string getUnusedVariableName(){
            // todo
            return "";
        }
        void copyParser(Scope & x){
            tsParser = x.tsParser;
        }
        TSNode getParsedNode(){
            string & buffer = *this->buffer;
            TSParser * tsParser = this->tsParser;
            TSTree * tree = ts_parser_parse_string(
                tsParser,
                NULL,
                buffer.c_str(),
                (int)((buffer).size())
            );
            return ts_tree_root_node(tree);
        }
    };
    
    
    
    class ReturnValue{
    public:
        ReturnValue(){
            dt = nullptr;
        }
        data_type* dt;
    };
}

namespace tree_sitter_simplified_proc {
    using namespace tree_sitter_data_structures;
    inline const char * type(TSNode & x){
        return ts_node_type(x);
    }
    inline bool is_type(TSNode & x, const char * tp){
        return strcmp(tp, type(x)) == 0;
    }
    inline bool is_type_of(TSNode & x, set<string> & tp){
        return tp.find(type(x)) != tp.end();
    }

    // cc = child count
    inline int cc(TSNode & x) {
        return  ts_node_child_count(x);
    }

    inline TSNode ch(TSNode & x, int i) {
        return ts_node_child(x, i);
    }

    using lambda_child_travse = const function<void(TSNode)>&;
    void getch(TSNode & x, lambda_child_travse y){
        for(int i = (0); i < (cc(x)); i++){
            y(ch(x,i));
        }
    }
    inline int start(TSNode & x) {
        return ts_node_start_byte(x);
    }

    inline int end(TSNode & x) {
        return ts_node_end_byte(x);
    }
    string substring(Scope & scope, int st, int ed){
        return scope.buffer->substr(st, ed-st);
    }

    string substring(Scope & scope, TSNode x){
        return substring(scope, start(x), end(x));
    }

    // vs Explode(str s, str delim){
    //     vs ret;
    //     int curp = 0;
    //     int nextp = 0;
    //     while(nextp != -1){
    //         nextp = s.find(delim, curp);
    //         if(nextp != -1){
    //             ret.pb(s.substr(curp, nextp - curp));
    //             curp = nextp + sz(delim);
    //         }else{
    //             ret.pb(s.substr(curp));
    //         }
    //     }
    //     return ret;
    // }
    Seq Explode(const string & x, string delim){
        Seq ret;
        int curp = 0;
        int nextp = 0;
        while(nextp != -1){
            nextp = x.find(delim, curp);
            if(nextp != -1){
                data_type * tp = data_type::newInstance();
                tp->content = x.substr(curp, nextp - curp);
                ret.push_back(tp);
                curp = nextp + (int)((delim).size());
            }else{
                data_type * tp = data_type::newInstance();
                tp->content = x.substr(curp);
                ret.push_back(tp);
            }
        }
        return ret;
    }
    string trim(string & x){
        int st = 0;
        int ed = (int)((x).size());
        while(st < ed && (isspace(x[st]) || x[st] == '\n' || x[st] == '\r')){
            st++;
        }
        while(st < ed && (isspace(x[ed-1]) || x[ed-1] == '\n' || x[ed-1] == '\r')){
            ed--;
        }
        return x.substr(st, ed-st);
    }
    Seq Explode(Seq& st, string delim){
        Seq ret;
        for(int i = (0); i < ((int)((st).size())); i++){
            if(st[i]->type == "" && st[i]->isString()){
                Seq ss = Explode(st[i]->toString(), delim);
                ret.insert(ret.end(), ss.begin(), ss.end());
            }else{
                ret.push_back(st[i]);
            }
        }
        return ret;
    }

    Seq replace(Seq & st, string delim, data_type * end){
        Seq ret;
        for(int i = (0); i < ((int)((st).size())); i++){
            if(st[i]->type == "" && st[i]->isString()){
                Seq ss = Explode(st[i]->toString(), delim);
                for(int j = (0); j < ((int)((ss).size())); j++){
                    ret.push_back(ss[j]);
                    if(j+1 != (int)((ss).size())){
                        ret.push_back(end);
                    }
                }
            }else{
                ret.push_back(st[i]);
            }
        }
        return ret;
    }

    Seq Implode(const Seq & s, data_type* delim){
        Seq ret; 
        for(int i = (0); i < ((int)((s).size())); i++){
            ret.push_back(s[i]);
            if(i + 1 != (int)((s).size())){
                ret.push_back(delim);
            }
        }
        return ret;
    }
}
using namespace  tree_sitter_simplified_proc;

namespace tree_sitter_debug_namespace {
    class debugString{
    public:
        string second;
        debugString(string x) : second(x){
        }
        debugString(){
            s = "";
        }
        string operator()(){
            return s;
        }
        debugString operator+(debugString & x){
            return debugString(s + x.second);
        }
        debugString operator+(string x){
            return debugString(s + x);
        }
        debugString& operator+=(string x){
            s += x;
            return *this;
        }
    };

    ostream & operator<<(ostream & os, debugString & x){
        if(c_dbg){
            os << x();
        }
        return os;
    }
};

using namespace tree_sitter_debug_namespace;

extern "C" {
     TSLanguage* tree_sitter_cpp();
}


#define repb(i, x) getch(x, [&](TSNode i){ str p_content = substring(scope, x);
#define repe });




//function prototype void parse(TSNode & node, Scope & scope, ReturnValue & retval)

using parse_proc = function<void(TSNode&, Scope & , ReturnValue &)>;
using parse_proc_ref = parse_proc &;
using const_parse_proc_ref = const parse_proc &;
class statement_handler;
map<string, statement_handler*> statement_handlers;

#define prel(x, y) data_type* dt = data_type::newInstance();\
dt->type = type(x);\
y.dt = nullptr;\
\
\

#define prel_typed(x, y, tp) tp* dt = tp::newInstance();\
dt->type = type(x);\
y.dt = nullptr;\
\
\




#define adds(s)             dt->isSequential = true;\
dt->sq.push_back(s.dt);\
\


#define posl(x) x.dt = dt;



class statement_handler{
public:
    void registerHandler(vector<string> & x){
        for(auto & i : x)statement_handlers[i] = this;
    }
    virtual vector<string> getAllTypes() = 0;
    virtual void handle(TSNode & node, Scope & scope, ReturnValue & retVal, const_parse_proc_ref parse) = 0;
    data_type * addDeclaration(data_type * dt, Scope & scope , bool isFunction){
            data_type * ndt = data_type::newInstance();
            ndt->content = "[insert declaration]";
            ndt->type = "insertion";
            if(isFunction){
                auto fund = getFunctionDeclaration(dt);
                scope.add_function(fund.first, fund.second, dt, ndt);
            }else{
                auto vard = getVariableDeclaration(dt);
                scope.add_variable(vard,  dt, ndt);
            }
            if(scope.isInserting || forced_display_variable_insertion){
                return ndt;
            }
            return dt;
    }
};
// template for statement handler
// class x_statement : public statement_handler{
// public:
//     x_statement(){
//         this->registerHandler(getAllTypes());
//     }
//     vs getAllTypes() override{
//         return {};
//     }
//     void handle(TSNode & node, Scope & scope, ReturnValue & retVal, const_parse_proc_ref parse) {
//          prel(node, retVal);
//          int curp = start(node);
//          repb(child, node)   
//              addp(substring(scope, curp, start(child)));
//              parse(child, scope, retVal);
//              adds(retVal);
//              curp = end(child);
//          repe
//          if(curp != end(node)){
//              addp( substring(scope, curp, end(node)) );
//          }
//          posl(retVal);
//      }
// }x_statement_handler;

class compound_statement : public statement_handler{
public:
    compound_statement(){
        this->registerHandler(getAllTypes());
    }
    vector<string> getAllTypes() override{
        return {"compound_statement", "declaration_list", "field_declaration_list"};
    }
    void handle(TSNode & node, Scope & scope, ReturnValue & retVal, const_parse_proc_ref parse) {
        prel(node, retVal);
        int curp = start(node);
        repb(child, node)   
            addp(substring(scope, curp, start(child)));
            parse(child, scope, retVal);
            adds(retVal);
            curp = end(child);
        repe
        if(curp != end(node))  addp(substring(scope, curp, end(node)));
        posl(retVal);
    }

};
compound_statement compound_like_statement_handler;


class type_identifier : public statement_handler{
public:
    type_identifier(){
        replacingTypes["ll"] = "long long";
        replacingTypes["ull"] = "unsigned long long";
        replacingTypes["db"] = "long double";
        replacingTypes["str"] = "string";
        replacingTypes["i64"] = "long long";
        replacingTypes["u64"] = "unsigned long long";
        replacingTypes["i32"] = "int";
        replacingTypes["u32"] = "unsigned int";
        replacingTypes["vi"] = "vector<int>";
        replacingTypes["vb"] = "vector<bool>";
        replacingTypes["vl"] = "vector<long long>";
        replacingTypes["vd"] = "vector<long double>";
        replacingTypes["vs"] = "vector<string>";
        replacingTypes["vpi"] = "vector<pair<int, int>>";
        replacingTypes["vpl"] = "vector<pair<long long, long long>>";
        replacingTypes["vpd"] = "vector<pair<long double, long double>>";
        replacingTypes["pi"] = "pair<int, int>";
        replacingTypes["pl"] = "pair<long long, long long>";
        replacingTypes["pd"] = "pair<long double, long double>";
        this->registerHandler(getAllTypes());
    }
    vector<string> getAllTypes() override{
        return {"type_identifier"};
    }
    map<string, string> replacingTypes;

    void generateType(data_type * dt, Scope & scope, string & type, const_parse_proc_ref parse){
        Scope nScope(nullptr);
        nScope.copyParser(scope);
        string tmps = type;
        nScope.buffer = &tmps;
        TSNode nRoot = nScope.getParsedNode();
        ReturnValue nRetVal;
        parse(nRoot, nScope, nRetVal); 
        data_type * tmp = nRetVal.dt;
        dt->add(tmp);
        dt->isSequential = true;
    }

    void handle(TSNode & node, Scope & scope, ReturnValue & retVal, const_parse_proc_ref parse) {
        prel(node, retVal);
        int curp = start(node);
        string text = substring(scope, node);
        assert(cc(node) == 0);
        if(replacingTypes.count(text)){
            generateType(dt, scope, replacingTypes[text], parse);
        }else{
            int vcnt = -1;
            for(int i = (0); i < ((int)((text).size())); i++){
                if(text[i] == 'v'){
                    ++vcnt;
                }else{
                    break;
                }
            }
            
            if(vcnt >= 0){
                string sub = text.substr(vcnt);
                if((int)((sub).size()) > 0){
                    if(sub[0] == 'v' && replacingTypes.count(sub)){
                        stringstream ss;
                        //add vector before 
                        for(int j = (0); j < (vcnt); j++){
                            ss << "vector<";
                        }
                        ss << replacingTypes[sub];
                        //add vector after
                        for(int j = (0); j < (vcnt); j++){
                            ss << ">";
                        }
                        generateType(dt, scope, to_string(ss), parse);
                        posl(retVal);
                        return;
                    }
                }
            }
            addp(text);
        }
        posl(retVal);
    }

};
type_identifier type_identifier_handler;


//field_identifier
class field_identifier : public statement_handler{
public:
    field_identifier(){
        this->registerHandler(getAllTypes());
        replacingTypes["f"] = "first";
        replacingTypes["s"] = "second";
        replacingTypes["rsz"] = "resize";    
        replacingTypes["ins"] = "insert";
        replacingTypes["pb"] = "push_back";
        replacingTypes["eb"] = "emplace_back";
        replacingTypes["ft"] = "front";
        replacingTypes["bk"] = "back";
        replacingTypes["tp"] = "top";
        replacingTypes["rbg"] = "rbegin";
        replacingTypes["red"] = "rend";
    }
    map<string, string> replacingTypes;
    vector<string> getAllTypes() override{
        return { "field_identifier" };
    }
    void handle(TSNode & node, Scope & scope, ReturnValue & retVal, const_parse_proc_ref parse) {
        assert(cc(node) == 0);
        string text = substring(scope, node);
        prel(node, retVal);
        if(replacingTypes.count(text)){
            addp(replacingTypes[text]);
        }else{
            addp(text);
        }
        posl(retVal);
    }
};
field_identifier field_identifier_handler;


//call_expression
class call_expression : public statement_handler{
public:
    call_expression(){
        this->registerHandler(getAllTypes());
        replacingTypes["mp"] = "make_pair";
        replacingFieldTypes["sz"] = "(int)((${0}).size())";
        replacingTypes["bg"] = "begin";
        replacingTypes["ed"] = "end";
        replacingTypes["pct"] = "__builtin_popcount";
        replacingFieldTypes["all"] = "begin(${0}), end(${0})";
        replacingFieldTypes["rall"] = "rbegin(${0}), rend(${0})";
        replacingFieldTypes["bits"] = "(${0} == 0 ? 0 : 31-__builtin_clz(${0}))";
        replacingFieldTypes["p2"] = "(1<<(${0}))";
        replacingFieldTypes["msk2"] = "((1<<(${0}))-1)";
    }
    //get maximum ${x} x's value
    int getMaxArgumentValue(string & x){
        int ret = 0;
        for(int i = (0); i < ((int)((x).size())); i++){
            if(x[i] == '$'){
                if(i + 1 < (int)((x).size()) && x[i+1] == '{'){
                    bool hit = false;
                    string tmp = "";
                    for(int j = (i+2); j < ((int)((x).size())); j++){
                        if(x[j] == '}'){
                            hit = true;
                            break;
                        }
                        tmp += x[j];
                    }
                    if(hit && numberOnly(tmp)){
                        ret = max((long long)ret, stoll(tmp)); // TODO: we can use chmax here
                    }
                }
            }
        }
        return ret+1;
    }
    bool numberOnly(const string & x){
        for(int i = (0); i < ((int)((x).size())); i++){
            if(!isdigit(x[i])){
                return false;
            }
        }
        return true;
    }

    data_type* toFun(string functionName, data_type* _args){
        string x = replacingFieldTypes[functionName];
        data_type * args = (*_args)[0];
        Seq sq; 
        for(int i = (0); i < ((int)((*args).size())); i++){
            data_type* cur = (*args)[i];
            if(cur->type == "") continue;
            if(cur->type == "(") continue;
            if(cur->type == ")") continue;
            if(cur->type == ",") continue;
            sq.push_back(cur);
        }
        int mx = getMaxArgumentValue(x);
        Seq cur;
        data_type * rxt = data_type::newInstance();
        rxt->content = x;
        cur.push_back(rxt);
        assert(mx == (int)((sq).size()));
        for(int i = (0); i < (mx); i++){
            string deliminator = "${" + to_string(i) + "}";
            cur = replace(cur, deliminator, sq[i]);
            //cur = Implode(Explode(cur, deliminator), sq[i]);
        }
        
        // replace "args" with args 
        data_type * ret = data_type::newInstance();
        ret->addAll(cur);
        return ret;
    }

    map<string, string> replacingTypes, replacingFieldTypes;
    vector<string> getAllTypes() override{
        return { "call_expression" };
    }
    void handle(TSNode & node, Scope & scope, ReturnValue & retVal, const_parse_proc_ref parse) {
        prel(node, retVal);
        int curp = start(node);
        bool sentenced = false;
        ReturnValue tmp;
        string funName = "";
        data_type * tdt = data_type::newInstance();
        repb(child, node)
            string ctext = substring(scope, child);   
            if(is_type(child, "identifier")){
                if(replacingFieldTypes.count(ctext)){
                    funName = ctext;
                    sentenced = true;
                }
            }else{
                if(sentenced)  {
                    parse(child, scope, tmp);
                    tdt->add(tmp.dt);
                }
            }
            curp = end(child);
        repe
        if(sentenced){
            auto args = tdt;
            dt->add(toFun(funName, args));
            addp( substring(scope, curp, end(node)) );
            posl(retVal);
            return;
        }
        curp = start(node);
        repb(child, node)
            string ctext = substring(scope, child);   
            addp(substring(scope, curp, start(child)));
            if(is_type(child, "identifier")){
                if(replacingTypes.count(ctext)){
                    addp(replacingTypes[ctext]);
                }else{
                    addp(ctext);
                }
            }else{
                parse(child, scope, retVal);
                adds(retVal);
            }
            curp = end(child);
        repe
        if(curp != end(node)){
            addp( substring(scope, curp, end(node)) );
        }
        posl(retVal);
    }
};
call_expression call_expression_handler;


//identifier
class identifier : public statement_handler{
public:
    identifier(){
        this->registerHandler(getAllTypes());
        replacingTypes["int_inf"] = "1073709056";
        replacingTypes["ll_inf"] = "4611686016279904256LL";
        replacingTypes["double_inf"] = "1e150";
        replacingTypes["PI"] = "3.14159265359";
    }
    vector<string> getAllTypes() override{
        return { "identifier" };
    }
    map<string, string> replacingTypes;
    void handle(TSNode & node, Scope & scope, ReturnValue & retVal, const_parse_proc_ref parse) {
        prel(node, retVal);
        string text = substring(scope, node);
        assert(cc(node) == 0);
        if(replacingTypes.count(text)){
            addp(replacingTypes[text]);
        }else{
            addp(text);
        }
        posl(retVal);
    }
};
identifier identifier_handler;



class repeat_statement : public statement_handler{
public:
    repeat_statement(){
        this->registerHandler(getAllTypes());
    }
    vector<string> getAllTypes() override{
        return {"repeat_statement"};
    }
    vector<string> getRepeatKeyTypes(){
        return {  "rep_perm", "rep_scomb",  "rep_mcomb",  "rep_sarr", "rep_marr",  "rep", "rrep",  "REP",  "RREP", "rep_dist", "each" };
    }
    vector<string> getImportantToken(){
        return {"(", ")", "[", "]", ","};
    }

    void handleTemplate(string & head, 
                        string &  templateFormulation,
                        vector<data_type*> & positionArgs,
                        data_type* body,
                        Scope & scope,
                        data_type * retVal){
    
        // process the head
        DataTypeStream ss;
        // todo if positionArgs[0] is already within the scope
        bool repType = (head == "rep" || head == "rrep");
        if(repType && templateFormulation == "()"){
            // todo if we have get unused variable name from scope
            string unusedName = scope.getUnusedVariableName();
            if(head == "rep"){
                ss << "for(int " << unusedName << " = ("<<0 << "); "<<  unusedName << " < (" <<  positionArgs[0] << "); "<< unusedName <<"++)";
            }else if(head == "rrep"){
                ss << "for(int " << unusedName << " = (("<<positionArgs[0] << ")-1); "<<  unusedName << " >= (0); "<< unusedName <<"--)";
            }
        }
        if(repType && templateFormulation == "(,)"){
            if(head == "rep"){
                ss << "for(int " << positionArgs[0] << " = ("<<0 << "); "<< positionArgs[0] << " < (" <<  positionArgs[1] << "); "<< positionArgs[0] <<"++)";
            }else if(head == "rrep"){
                ss << "for(int " << positionArgs[0] << " = (("<< positionArgs[1]  << ")-1); "<< positionArgs[0] << " >= 0; "<< positionArgs[0] <<"--)";
            }
        }
        if(repType && templateFormulation == "(,,)"){
            if(head == "rep"){
                ss << "for(int " << positionArgs[0] << " = ("<< positionArgs[1] << "); "<< positionArgs[0] << " < (" << positionArgs[2] << "); "<< positionArgs[0] <<"++)";
            }else if(head == "rrep"){
                ss << "for(int " << positionArgs[0] << " = (("<< positionArgs[2] << ")-1); "<< positionArgs[0] << " >= (" << positionArgs[1] << "); "<< positionArgs[0] <<"--)";
            }    
        }
        if (repType &&  templateFormulation == "(,,,)"){
            if(head == "rep"){
                ss << "for(int " << positionArgs[0] << " = ("<< positionArgs[1] << "); "<< positionArgs[0] << " < (" << positionArgs[2] << "); "<< positionArgs[0] <<"+= (" << positionArgs[3] << "))";
            }else if(head == "rrep"){
                ss << "for(int " << positionArgs[0] << " = (("<< positionArgs[2] << ")-1); "<< positionArgs[0] << " >= (" << positionArgs[1] << "); "<< positionArgs[0] <<"-= (" << positionArgs[3] << "))";
            }
        }
        if(head == "each" && templateFormulation == "(,)"){
            ss << "for(auto & " << positionArgs[0] << " : " << positionArgs[1] << ")";
        }
        retVal->addAll(ss.getSeq());
        // process the body if we keep the body intact
        retVal->add(body);
        
        // process the tail
    }

    void handle(TSNode & node, Scope & scope, ReturnValue & retVal, const_parse_proc_ref parse) {
        prel(node, retVal);
        int curp = start(node);
        set<string> importantTypes = toSet(getImportantToken());
        set<string> originatorTypes = toSet(getRepeatKeyTypes());
        string templateFormulation = "";
        string head = "";
        vector<data_type*> positionArgs;
        bool encountered = false;
        data_type* rest;
        repb(child, node)   
            if(is_type(child, ")")) encountered = true;
            if(is_type_of(child, importantTypes)){
                templateFormulation += type(child);
                return;
            }
            if(is_type_of(child, originatorTypes)){
                head = type(child);
                return;
            }
            if(!encountered){
                ReturnValue tmp;
                parse(child, scope, tmp);
                curp = end(child);
                positionArgs.push_back(tmp.dt);
            }else{
                ReturnValue tmp;
                parse(child, scope, tmp);
                curp = end(child);
                rest = tmp.dt;
            }
        repe
        handleTemplate(head, templateFormulation, positionArgs, rest, scope, dt);
        if(curp != end(node)){
            addp( substring(scope, curp, end(node)) );
        }
        posl(retVal);
    }
};
repeat_statement repeat_statement_handler;


// TODO template_declaration handler
class template_declaration : public statement_handler{
public:
    template_declaration(){
        this->registerHandler(getAllTypes());
    }
    vector<string> getAllTypes() override{
        return {"template_declaration"};
    }
    void handle(TSNode & node, Scope & scope, ReturnValue & retVal, const_parse_proc_ref parse) {
        prel(node, retVal);
        int curp = start(node);
        function_definition_data_type * functionDT = nullptr;
        Scope nScope(&scope);
        scope.passdown(nScope);

        repb(child, node)   
            addp(substring(nScope, curp, start(child)));
            parse(child, nScope, retVal);
            adds(retVal);
            if(is_type(child, "function_definition")){
                functionDT = dynamic_cast<function_definition_data_type*>(retVal.dt);
            }
            curp = end(child);
        repe
        
        if(curp != end(node)) addp(substring(nScope, curp, end(node)));
        if(functionDT){
            retVal.dt  = addDeclaration(dt, scope, true);
        }
        else{
            posl(retVal);
        }

    }
};
template_declaration template_declaration_handler;



class function_declarator : public statement_handler{
public:
    function_declarator(){
        this->registerHandler(getAllTypes());
    }
    vector<string> getAllTypes() override{
        return {"function_declarator"};
    }
    void handle(TSNode & node, Scope & scope, ReturnValue & retVal, const_parse_proc_ref parse) {
         prel_typed(node, retVal, function_declarator_data_type);
         int curp = start(node);
         parameter_list_data_type * fargc = nullptr;
         data_type * fname = nullptr;
         repb(child, node)   
             addp(substring(scope, curp, start(child)));
             parse(child, scope, retVal);
             adds(retVal);
             if(is_type(child, "parameter_list")){
                fargc = dynamic_cast<parameter_list_data_type*>(retVal.dt);
             }
             if(is_type_of(child, set<string>{"identifier"})){
                fname = retVal.dt; 
             }
             curp = end(child);
         repe
         if(curp != end(node)){
             addp( substring(scope, curp, end(node)) );
         }
         if(fname){
            dt->name = fname->toString();
         }
         if(fargc){
            dt->args = fargc->getArgsCount();
         }

         posl(retVal);
     }
};
function_declarator function_declarator_handler;


class function_definition : public statement_handler{
public:
    function_definition(){
        this->registerHandler(getAllTypes());
    }
    vector<string> getAllTypes() override{
        return { "function_definition" };
    }
    void handle(TSNode & node, Scope & scope, ReturnValue & retVal, const_parse_proc_ref parse) {
         prel_typed(node, retVal, function_definition_data_type);
         Scope nScope(&scope);
         scope.passdown(nScope);

         Scope & cScope = [&](){
                if(!is_type(ts_node_parent(node), "template_declaration")){
                    return nScope;
                }else{
                    return  scope;
                }
         }();
         
         
         int curp = start(node);
         repb(child, node)   
             addp(substring(cScope, curp, start(child)));
             parse(child, cScope, retVal);
             adds(retVal);
             curp = end(child);
         repe
         if(curp != end(node)) addp( substring(cScope, curp, end(node)) );
         dt->usages = cScope.vUsage;
         if(!is_type(ts_node_parent(node), "template_declaration")){
            retVal.dt  = addDeclaration(dt, scope, true);
         }
         else{
             posl(retVal);
         }
     }
};
function_definition function_definition_handler;


class parameter_list : public statement_handler{
public:
    parameter_list(){
        this->registerHandler(getAllTypes());
    }
    vector<string> getAllTypes() override{
        return {"parameter_list"};
    }
    void handle(TSNode & node, Scope & scope, ReturnValue & retVal, const_parse_proc_ref parse) {
         prel_typed(node, retVal, parameter_list_data_type);
         int curp = start(node);
         
         repb(child, node)   
             addp(substring(scope, curp, start(child)));
             parse(child, scope, retVal);
             adds(retVal);
             curp = end(child);
         repe
         if(curp != end(node)){
             addp( substring(scope, curp, end(node)) );
         }
        int ct = dt->getArgsCount();
         posl(retVal);
     }
    
} ;
parameter_list parameter_list_handler;



class comment : public statement_handler{
public:
    comment(){
        this->registerHandler(getAllTypes());
    }
    vector<string> getAllTypes() override{
        return { "comment"};
    }
    void handle(TSNode & node, Scope & scope, ReturnValue & retVal, const_parse_proc_ref parse) {
         prel(node, retVal);
         int curp = start(node);
         assert(cc(node) == 0);
         if(trim(substring(scope, node)) == "//linking_begin"){
            scope.isInserting = true;
         }else  if(trim(substring(scope, node)) == "//linking_end"){
            scope.isInserting = false;
         }
         if(curp != end(node)){
             addp( substring(scope, curp, end(node)) );
         }
         posl(retVal);
     }
};
comment comment_statement_handler;



class class_specifier : public statement_handler{
public:
    class_specifier(){
        this->registerHandler(getAllTypes());
    }
    vector<string> getAllTypes() override{
        return { "class_specifier" };
    }
    void handle(TSNode & node, Scope & scope, ReturnValue & retVal, const_parse_proc_ref parse) {
         prel_typed(node, retVal, class_specifier_data_type);
         int curp = start(node);
         repb(child, node)   
             addp(substring(scope, curp, start(child)));
             parse(child, scope, retVal);
             adds(retVal);
             curp = end(child);
         repe
         if(curp != end(node)){
             addp( substring(scope, curp, end(node)) );
         }
         posl(retVal);
     }
};
class_specifier class_specifier_handler;



class declaration : public statement_handler{
public:
    declaration(){
        this->registerHandler(getAllTypes());
    }
    vector<string> getAllTypes() override{
        return { "declaration", "field_declaration" };
    }

    // TODO: read_declarator
    set<string> getAllIdentifierType(){
        return set<string>({
            "attributed_declarator", 
            "pointer_declarator", 
            "function_declarator", 
            "array_declarator", 
            "parenthesized_declarator", 
            "identifier", 
            "init_declarator", 
            "field_identifier"});
    }    
    void handle(TSNode & node, Scope & scope, ReturnValue & retVal, const_parse_proc_ref parse) {
         prel(node, retVal);
         int curp = start(node);
         vector<data_type*>  preType;
         vector<data_type*>  identifiersList; 
         repb(child, node)   
             addp(substring(scope, curp, start(child)));
             parse(child, scope, retVal);
             adds(retVal);
             curp = end(child);
         repe
         if(curp != end(node)){
             addp( substring(scope, curp, end(node)) );
         }
         set<string> allIdentiferType = getAllIdentifierType();
         bool beginning = true;
         data_type * prec = data_type::newInstance();
         prec->type = "identifier_declarator";
         for(auto & x : dt->sq){
            if(allIdentiferType.count(x->type)){
                beginning = false;
            }
            if(!beginning && x->type != ";" && x->type != ","){
                prec->add(x);
            }
            if(!beginning && x->type == ";" || x->type == ",") {
                identifiersList.push_back(prec);
                prec = data_type::newInstance();
                prec->type = "identifier_declarator";
                continue;
            }
            if(beginning){
                preType.push_back(x);
            }
         }
         //get padding 
         string spd;
         for(int i = ((curp)-1); i >= (0); i--){
            if((*scope.buffer)[i] == '\n' ) break;
            spd += (*scope.buffer)[i];
         }
         reverse(spd.begin(), spd.end());
         string ppdx;
         for(int i = (0); i < ((int)((spd).size())); i++){
            if(spd[i] != ' ' && spd[i] != '\t') break;
            ppdx += spd[i];
         }
         if(dt->get(0)->type == "class_specifier"){
            data_type * ndt = data_type::newInstance();
            ndt->addAll(preType);
            addpp(ndt, ";\n" , ";");
            ndt->type = "translation_unit";
            class_specifier_data_type * csdt = dynamic_cast<class_specifier_data_type*>(dt->get(0));
            if(csdt != nullptr){
                for(auto & id : identifiersList){
                    data_type * nxdt = data_type::newInstance();
                    nxdt->type = "declaration";
                    addpp(nxdt, ppdx, "");
                    addpp(nxdt, csdt->getName(), csdt->getName());
                    addpp(nxdt, " " , "");
                    nxdt->add(id);
                    addpp(nxdt, ";\n" , ";");
                    ndt->add(addDeclaration(nxdt, scope, false));
                }
            }
            retVal.dt = ndt;
         }else{
            data_type * ndt = data_type::newInstance();
            ndt->type = "translation_unit";
            for(int i = (0); i < ((int)((identifiersList).size())); i++){
                data_type * nxdt = data_type::newInstance();
                nxdt->type = "declaration";
                auto& id = identifiersList[i];
                string padding = ";";
                if(i != (int)((identifiersList).size())-1){
                    padding += "\n";
                }
                if(i != 0){
                    data_type * idt = data_type::newInstance();
                    idt->content = ppdx;
                    nxdt->add(idt);
                }
                nxdt->addAll(preType);
                nxdt->add(id);
                addpp(nxdt, padding , ";");
                ndt->add(addDeclaration(nxdt, scope, false));
            }
            retVal.dt = ndt;
         }
     }
};
declaration declaration_handler;



void parse(TSNode & node, Scope & scope, ReturnValue & retval){
    prel(node, retval);
    string nodeType = type(node);
    string content = substring(scope, start(node), end(node));
    
    if(statement_handlers.count(nodeType) != 0){
        statement_handlers[nodeType]->handle(node, scope, retval, parse);
        return;
    }
    int curp = start(node);
    repb(child, node)
        addp(substring(scope, curp, start(child)));
        parse(child, scope, retval);
        adds(retval);
        curp = end(child);
    repe
    if(curp != end(node)){ 
        addp( substring(scope, curp, end(node)) );
    }
    posl(retval);
}





int main(){
    string  buffer;
    string  bf;
    //get from iostream 
    while(!cin.eof()){
        string tmp = "";    
        getline(cin, tmp);
        buffer += tmp + "\n";
    }
    TSParser * tsParser = ts_parser_new();
    ts_parser_set_language(tsParser, tree_sitter_cpp());
	
    TSNode root;
    Scope scope(nullptr);
    scope.buffer = &buffer;
    scope.tsParser = tsParser;
    root = scope.getParsedNode();
    ReturnValue retval;
    parse(root, scope, retval);
    retval.dt->show();
    //print all kinds
    retval.dt->show_debug(0);
 

    return 0;
}
